tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts(2,29): error TS2314: Generic type 'Functor1' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts(16,29): error TS2314: Generic type 'InvalidImplementor' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts(42,29): error TS2314: Generic type 'InvalidExtender' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts(59,7): error TS2515: Non-abstract class 'InvalidIndirectExtender<A>' does not implement inherited abstract member 'map' from class 'ValidExtender<A>'.
tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts(69,15): error TS2314: Generic type 'GenericThisMustBeInMethod' requires ***generic 'this' types can only occur in methods*** type argument(s).


==== tests/cases/compiler/higherKindedTypesGenericThisExpectedErrors.ts (5 errors) ====
    export class Functor1<A> {
        map<B>(f: (a: A) => B): this<B> {
                                ~~~~~~~
!!! error TS2314: Generic type 'Functor1' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
            return this;
        }
    }
    
    
    
    interface ValidFunctor<A> {
        map<B>(f: (a: A) => B): this<B>
    }
    
    class InvalidImplementor<A> implements ValidFunctor<A> {
        constructor(private elements: A[]) { };
    
        map<B>(f: (a: A) => B): this<B> { // should declare return type as InvalidImplementor<B> to not be invalid.
                                ~~~~~~~
!!! error TS2314: Generic type 'InvalidImplementor' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
            const newElements = this.elements.map(f);
            return new InvalidImplementor(newElements);
        }
    }
    
    
    class ValidImplementor<A> implements ValidFunctor<A> {
        constructor(private elements: A[]) {};
    
        map<B>(f: (a: A) => B): ValidImplementor<B> { 
            const newElements = this.elements.map(f);
            return new ValidImplementor(newElements);
        }
    }
    
    
    abstract class ValidAbstractFunctor<A> {
        abstract map<B>(f: (a: A) => B): this<B>;
    }
    
    class InvalidExtender<A> extends ValidAbstractFunctor<A> {
        constructor(private elements: A[]) { 
            super();
        };
    
        map<B>(f: (a: A) => B): this<B> { // should declare return type as InvalidImplementor<B> to not be invalid.
                                ~~~~~~~
!!! error TS2314: Generic type 'InvalidExtender' requires ***generic 'this' types can only occur in abstract methods*** type argument(s).
            const newElements = this.elements.map(f);
            return new InvalidExtender(newElements);
        }
    }
    
    
    class ValidExtender<A> extends ValidAbstractFunctor<A> {
        constructor(private elements: A[]) {super()};
    
        map<B>(f: (a: A) => B): ValidExtender<B> { 
            const newElements = this.elements.map(f);
            return new ValidExtender(newElements);
        }
    }
    
    // invalid because it must redeclare "map" itself even though its parent implemented it
    class InvalidIndirectExtender<A> extends ValidExtender<A> {
          ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2515: Non-abstract class 'InvalidIndirectExtender<A>' does not implement inherited abstract member 'map' from class 'ValidExtender<A>'.
        doSomething(): void {
            console.log("");
        }
    }
    
    
    
    
    interface GenericThisMustBeInMethod<T> {
        someProp: this<T>
                  ~~~~~~~
!!! error TS2314: Generic type 'GenericThisMustBeInMethod' requires ***generic 'this' types can only occur in methods*** type argument(s).
    }