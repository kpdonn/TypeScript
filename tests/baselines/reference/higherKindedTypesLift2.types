=== tests/cases/compiler/higherKindedTypesLift2.ts ===
interface StartVal {
>StartVal : StartVal

    startVal: string
>startVal : string
}

interface EndVal {
>EndVal : EndVal

    endVal: number
>endVal : number
}

declare function testFunc(strarg: StartVal): EndVal
>testFunc : (strarg: StartVal) => EndVal
>strarg : StartVal
>StartVal : StartVal
>EndVal : EndVal

export interface FMap<FA, FB> {
>FMap : FMap<FA, FB>
>FA : FA
>FB : FB

    (fmapfa: FA): FB
>fmapfa : FA
>FA : FA
>FB : FB
}

interface Bounded<
>Bounded : Bounded<BC, Bound, BT, BTBound>

    BC<_BCT extends BTBound> extends Bound<BC, _BCT, BTBound>,
>BC : BC
>_BCT : _BCT
>BTBound : BTBound
>Bound : Bound
>BC : BC
>_BCT : _BCT
>BTBound : BTBound

    Bound<
>Bound : Bound

        _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

        _BT,
>_BT : _BT

        _BTB
>_BTB : _BTB

    >,
    BT extends BTBound,
>BT : BT
>BTBound : BTBound

    BTBound
>BTBound : BTBound

> {}

interface Functor<
>Functor : Functor<CX, AX, AXBound>

    CX<_TX extends _TXB, _TXB = {}> extends Functor<CX, _TX, _TXB>,
>CX : CX
>_TX : _TX
>_TXB : _TXB
>_TXB : _TXB
>Functor : Functor<CX, AX, AXBound>
>CX : CX
>_TX : _TX
>_TXB : _TXB

    AX extends AXBound,
>AX : AX
>AXBound : AXBound

    AXBound
>AXBound : AXBound

    > 
        extends Bounded<CX, Functor, AX, AXBound> {
>Bounded : Bounded<BC, Bound, BT, BTBound>
>CX : CX
>Functor : Functor<CX, AX, AXBound>
>AX : AX
>AXBound : AXBound

    functorMap<BX extends AXBound>(fmapx: FMap<AX, BX>): CX<BX>;
>functorMap : <BX extends AXBound>(fmapx: FMap<AX, BX>) => CX
>BX : BX
>AXBound : AXBound
>fmapx : FMap<AX, BX>
>FMap : FMap<FA, FB>
>AX : AX
>BX : BX
>CX : CX
>BX : BX
}

interface StaticFunctor<
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>

    SC<_T extends _TB, _TB = {}> extends SCBound<SC, _T, _TB> & Bounded<SC, SCBound, _T, _TB>,
>SC : SC
>_T : _T
>_TB : _TB
>_TB : _TB
>SCBound : SCBound
>SC : SC
>_T : _T
>_TB : _TB
>Bounded : Bounded<BC, Bound, BT, BTBound>
>SC : SC
>SCBound : SCBound
>_T : _T
>_TB : _TB

    SCBound<
>SCBound : SCBound

     _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

     _BT,
>_BT : _BT

     _BTB
>_BTB : _BTB

    >,
    SCTBound = {}
>SCTBound : SCTBound

> {
    <AS extends SCTBound, BS extends SCTBound>(fa2: SC<AS>, fmap2: FMap<AS,BS>): SC<BS>
>AS : AS
>SCTBound : SCTBound
>BS : BS
>SCTBound : SCTBound
>fa2 : SC
>SC : SC
>AS : AS
>fmap2 : FMap<AS, BS>
>FMap : FMap<FA, FB>
>AS : AS
>BS : BS
>SC : SC
>BS : BS
}


declare function lift<
>lift : <C extends ActBound & Bounded<C, ActBound, any, {}>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>

    C<_T extends _TB, _TB = {}> extends ActBound<C, _T, _TB> & Bounded<C, ActBound, _T, _TB>,
>C : C
>_T : _T
>_TB : _TB
>_TB : _TB
>ActBound : ActBound
>C : C
>_T : _T
>_TB : _TB
>Bounded : Bounded<BC, Bound, BT, BTBound>
>C : C
>ActBound : ActBound
>_T : _T
>_TB : _TB

    ActBound<
>ActBound : ActBound

    _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

    _BT,
>_BT : _BT

    _BTB
>_BTB : _BTB

   >,
    ActTBound
>ActTBound : ActTBound

>
(fToLift: StaticFunctor<C, ActBound, ActTBound>): LiftedResult<C, ActBound, ActTBound>
>fToLift : StaticFunctor<C, ActBound, ActTBound>
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>
>C : C
>ActBound : ActBound
>ActTBound : ActTBound
>LiftedResult : LiftedResult<LC, LRCBound, LRTBound>
>C : C
>ActBound : ActBound
>ActTBound : ActTBound


interface LiftedResult<
>LiftedResult : LiftedResult<LC, LRCBound, LRTBound>

    LC<_LT extends _TB, _TB = {}> extends LRCBound<LC, _LT, _TB> & Bounded<LC, LRCBound, _LT, _TB>,
>LC : LC
>_LT : _LT
>_TB : _TB
>_TB : _TB
>LRCBound : LRCBound
>LC : LC
>_LT : _LT
>_TB : _TB
>Bounded : Bounded<BC, Bound, BT, BTBound>
>LC : LC
>LRCBound : LRCBound
>_LT : _LT
>_TB : _TB

    LRCBound<
>LRCBound : LRCBound

    _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

    _BT,
>_BT : _BT

    _BTB
>_BTB : _BTB

   >,
   LRTBound 
>LRTBound : LRTBound

> {
    <LA, LB>(lmap: FMap<LA,LB>): LiftedResult2<LC, LA, LB, LRCBound>
>LA : LA
>LB : LB
>lmap : FMap<LA, LB>
>FMap : FMap<FA, FB>
>LA : LA
>LB : LB
>LiftedResult2 : LiftedResult2<LC2, LA2, LB2, LRC2Bound>
>LC : LC
>LA : LA
>LB : LB
>LRCBound : LRCBound
}

interface LiftedResult2<
>LiftedResult2 : LiftedResult2<LC2, LA2, LB2, LRC2Bound>

    LC2<_LT extends LA2 | LB2> extends LRC2Bound<LC2, _LT,  LA2 | LB2> & Bounded<LC2, LRC2Bound, _LT, LA2 | LB2>, 
>LC2 : LC2
>_LT : _LT
>LA2 : LA2
>LB2 : LB2
>LRC2Bound : LRC2Bound
>LC2 : LC2
>_LT : _LT
>LA2 : LA2
>LB2 : LB2
>Bounded : Bounded<BC, Bound, BT, BTBound>
>LC2 : LC2
>LRC2Bound : LRC2Bound
>_LT : _LT
>LA2 : LA2
>LB2 : LB2

    LA2,
>LA2 : LA2

    LB2,
>LB2 : LB2

    LRC2Bound<
>LRC2Bound : LRC2Bound

        _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

        _BT,
>_BT : _BT

        _BTB
>_BTB : _BTB

    >,
    > {
        <FinalC<_FT extends LA2 | LB2> extends LC2<_FT>>(lc2la2: FinalC<LA2>): FinalC<LB2>
>FinalC : FinalC
>_FT : _FT
>LA2 : LA2
>LB2 : LB2
>LC2 : LC2
>_FT : _FT
>lc2la2 : FinalC
>FinalC : FinalC
>LA2 : LA2
>FinalC : FinalC
>LB2 : LB2
    }

declare function staticMap<C1<_T1 extends _T1B, _T1B = {}> extends Functor<C1, _T1, _T1B>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1<A1>, fmap1: FMap<A1, B1>): C1<B1>;
>staticMap : <C1 extends Functor<C1, any, {}>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1, fmap1: FMap<A1, B1>) => C1
>C1 : C1
>_T1 : _T1
>_T1B : _T1B
>_T1B : _T1B
>Functor : Functor<CX, AX, AXBound>
>C1 : C1
>_T1 : _T1
>_T1B : _T1B
>T1Bound : T1Bound
>A1 : A1
>T1Bound : T1Bound
>B1 : B1
>T1Bound : T1Bound
>fa1 : C1
>C1 : C1
>A1 : A1
>fmap1 : FMap<A1, B1>
>FMap : FMap<FA, FB>
>A1 : A1
>B1 : B1
>C1 : C1
>B1 : B1


interface FunctorFoo<AFoo> extends Functor<FunctorFoo, AFoo, {}> {
>FunctorFoo : FunctorFoo<AFoo>
>AFoo : AFoo
>Functor : Functor<CX, AX, AXBound>
>FunctorFoo : FunctorFoo<AFoo>
>AFoo : AFoo

    functorMap<BFoo>(fmapfoo: FMap<AFoo, BFoo>): FunctorFoo<BFoo>;
>functorMap : <BFoo>(fmapfoo: FMap<AFoo, BFoo>) => FunctorFoo<BFoo>
>BFoo : BFoo
>fmapfoo : FMap<AFoo, BFoo>
>FMap : FMap<FA, FB>
>AFoo : AFoo
>BFoo : BFoo
>FunctorFoo : FunctorFoo<AFoo>
>BFoo : BFoo

    fooVal: AFoo
>fooVal : AFoo
>AFoo : AFoo
}

declare const fooObj: FunctorFoo<StartVal>
>fooObj : FunctorFoo<StartVal>
>FunctorFoo : FunctorFoo<AFoo>
>StartVal : StartVal



const liftedStaticMap = lift(staticMap);
>liftedStaticMap : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift(staticMap) : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift : <C extends ActBound & Bounded<C, ActBound, any, {}>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>
>staticMap : <C1 extends Functor<C1, any, {}>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1, fmap1: FMap<A1, B1>) => C1

const liftedTestFunc = liftedStaticMap(testFunc);
>liftedTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedStaticMap(testFunc) : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedStaticMap : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>testFunc : (strarg: StartVal) => EndVal

const result = liftedTestFunc(fooObj);
>result : Functor<CX, StartVal | EndVal, {}>
>liftedTestFunc(fooObj) : Functor<CX, StartVal | EndVal, {}>
>liftedTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>fooObj : FunctorFoo<StartVal>

const expectedType: FunctorFoo<EndVal> = result;
>expectedType : FunctorFoo<EndVal>
>FunctorFoo : FunctorFoo<AFoo>
>EndVal : EndVal
>result : Functor<CX, StartVal | EndVal, {}>

const expectError = liftedTestFunc(result)
>expectError : Functor<CX, StartVal | EndVal, {}>
>liftedTestFunc(result) : Functor<CX, StartVal | EndVal, {}>
>liftedTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>result : Functor<CX, StartVal | EndVal, {}>


declare const declaredStaticFunctor: StaticFunctor<Functor, Functor>
>declaredStaticFunctor : StaticFunctor<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>
>Functor : Functor<CX, AX, AXBound>
>Functor : Functor<CX, AX, AXBound>

const liftedDeclaredStaticFunctor = lift(declaredStaticFunctor);
>liftedDeclaredStaticFunctor : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift(declaredStaticFunctor) : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift : <C extends ActBound & Bounded<C, ActBound, any, {}>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>
>declaredStaticFunctor : StaticFunctor<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>

const liftedDeclaredTestFunc = liftedDeclaredStaticFunctor(testFunc)
>liftedDeclaredTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedDeclaredStaticFunctor(testFunc) : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedDeclaredStaticFunctor : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>testFunc : (strarg: StartVal) => EndVal

const declaredResult = liftedDeclaredTestFunc(fooObj);
>declaredResult : Functor<CX, StartVal | EndVal, {}>
>liftedDeclaredTestFunc(fooObj) : Functor<CX, StartVal | EndVal, {}>
>liftedDeclaredTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>fooObj : FunctorFoo<StartVal>

const expectedTypeDeclared: FunctorFoo<EndVal> = declaredResult;
>expectedTypeDeclared : FunctorFoo<EndVal>
>FunctorFoo : FunctorFoo<AFoo>
>EndVal : EndVal
>declaredResult : Functor<CX, StartVal | EndVal, {}>

const expectErrorDeclared = liftedDeclaredTestFunc(declaredResult)
>expectErrorDeclared : Functor<CX, StartVal | EndVal, {}>
>liftedDeclaredTestFunc(declaredResult) : Functor<CX, StartVal | EndVal, {}>
>liftedDeclaredTestFunc : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>declaredResult : Functor<CX, StartVal | EndVal, {}>

