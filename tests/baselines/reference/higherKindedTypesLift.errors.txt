tests/cases/compiler/higherKindedTypesLift.ts(7,5): error TS2416: Property 'map' in type 'FunctorX<A>' is not assignable to the same property in base type 'Functor<A, FunctorX<A>>'.
  Type '<B>(f: (a: A) => B) => FunctorX<B>' is not assignable to type '<B>(f: (a: A) => B) => FunctorX<A>'.
    Type 'FunctorX<B>' is not assignable to type 'FunctorX<A>'.
      Type 'B' is not assignable to type 'A'.
tests/cases/compiler/higherKindedTypesLift.ts(32,5): error TS2322: Type 'C1<A1>' is not assignable to type 'C1<B1>'.
  Type 'A1' is not assignable to type 'B1'.
tests/cases/compiler/higherKindedTypesLift.ts(48,40): error TS2345: Argument of type 'FunctorX<number>' is not assignable to parameter of type 'FunctorX<string>'.
  Type 'number' is not assignable to type 'string'.


==== tests/cases/compiler/higherKindedTypesLift.ts (3 errors) ====
    export interface Functor<A, Container<_T>> {
        map<B>(f: (a: A) => B): Container<B>;
    }
    
    class FunctorX<A> implements Functor<A, FunctorX> {
        constructor(private elements: A[]) {}
        map<B>(f: (a: A) => B): FunctorX<B> {
        ~~~
!!! error TS2416: Property 'map' in type 'FunctorX<A>' is not assignable to the same property in base type 'Functor<A, FunctorX<A>>'.
!!! error TS2416:   Type '<B>(f: (a: A) => B) => FunctorX<B>' is not assignable to type '<B>(f: (a: A) => B) => FunctorX<A>'.
!!! error TS2416:     Type 'FunctorX<B>' is not assignable to type 'FunctorX<A>'.
!!! error TS2416:       Type 'B' is not assignable to type 'A'.
            const mappedElements = this.elements.map(f);
            return new FunctorX(mappedElements);
        }
    
        firstVal(): A | undefined {
            return this.elements.length ? this.elements[0] : undefined;
        };
    }
    
    
    interface StaticFunctor<CS<_TS>> {
        <AS, BS>(csas: CS<AS>, fmapstatic: (as: AS) => BS): CS<BS>;
    }
    
    
    interface LiftedResult<LRC<_LT>> {
        <LRA, LRB>(lrmap: (lra: LRA) => LRB): <NC<_NT> extends LRC<_NT>>(lrclra: NC<LRA>) => NC<LRB>
    }
    
    function lift<C<_T>>(fToLift: StaticFunctor<C>): LiftedResult<C> {
        return lmap => lca => fToLift(lca, lmap);
    }
    
    function staticMap<C1<_T1> extends Functor<_T1, C1>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1): C1<B1> {
        return fa1.map(fmap1);
        ~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2322: Type 'C1<A1>' is not assignable to type 'C1<B1>'.
!!! error TS2322:   Type 'A1' is not assignable to type 'B1'.
    }
    
    const liftedFunctor = lift(staticMap);
    
    function stringLength(strarg: string): number {
        return strarg.length;
    }
    
    const liftedStringLength = liftedFunctor(stringLength);
    
    const functorXString = new FunctorX(["myFunctorX"]);
    
    const result = liftedStringLength(functorXString);
    const expectedType: FunctorX<number> = result;
    
    const expectError = liftedStringLength(result)
                                           ~~~~~~
!!! error TS2345: Argument of type 'FunctorX<number>' is not assignable to parameter of type 'FunctorX<string>'.
!!! error TS2345:   Type 'number' is not assignable to type 'string'.
    
    