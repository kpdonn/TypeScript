tests/cases/compiler/higherKindedTypesThisFunctor.ts(8,5): error TS2416: Property 'map' in type 'MyArrayFunctor<El>' is not assignable to the same property in base type 'Functor<El>'.
  Type '<NewEl>(newf: (el: El) => NewEl) => MyArrayFunctor<NewEl>' is not assignable to type '<B>(f: (fa: El) => B) => this'.
    Type 'MyArrayFunctor<B>' is not assignable to type 'this'.


==== tests/cases/compiler/higherKindedTypesThisFunctor.ts (1 errors) ====
    export interface Functor<A> {
        map<B>(f: (fa: A) => B): this<B>;
    }
    
    class MyArrayFunctor<El> implements Functor<El> {
        constructor(private elements: El[]) {};
    
        map<NewEl>(newf: (el: El) => NewEl): MyArrayFunctor<NewEl> {
        ~~~
!!! error TS2416: Property 'map' in type 'MyArrayFunctor<El>' is not assignable to the same property in base type 'Functor<El>'.
!!! error TS2416:   Type '<NewEl>(newf: (el: El) => NewEl) => MyArrayFunctor<NewEl>' is not assignable to type '<B>(f: (fa: El) => B) => this'.
!!! error TS2416:     Type 'MyArrayFunctor<B>' is not assignable to type 'this'.
            const newElements = this.elements.map(newf);
            return new MyArrayFunctor(newElements);
        }
    
        myMethod(): El {
            return this.elements[0];
        }
    }
    
    
    interface Foo {
        fooProp: string
    }
    
    interface Bar {
        barProp: string
    }
    
    function fooToBar(fooArg: Foo): Bar {
        return { barProp: fooArg.fooProp };
    }
    
    
    function convertAll<C<_T> extends
        Functor<_T>, OldT, NewT>
    (container: C<OldT>, convertFunc: (oldArg: OldT) => NewT): C<NewT> {
        const newContainer = container.map(convertFunc);
        return newContainer;
    }