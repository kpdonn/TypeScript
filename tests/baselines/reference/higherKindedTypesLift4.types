=== tests/cases/compiler/higherKindedTypesLift4.ts ===
export interface FMap<FA, FB> {
>FMap : FMap<FA, FB>
>FA : FA
>FB : FB

    (fmapfa: FA): FB
>fmapfa : FA
>FA : FA
>FB : FB
}

interface Bounded<
>Bounded : Bounded<BC, Bound, BT, BTBound>

    BC<_BCT> extends Bound<BC, _BCT>,
>BC : BC
>_BCT : _BCT
>Bound : Bound
>BC : BC
>_BCT : _BCT

    Bound<
>Bound : Bound

        _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

        _BT
>_BT : _BT

    >,
    BT extends BTBound,
>BT : BT
>BTBound : BTBound

    BTBound = BT
>BTBound : BTBound
>BT : BT

> {}

interface Functor<CX<_TX extends AXBound> extends Functor<CX, AX, AXBound>, AX extends AXBound, AXBound = AX> extends Bounded<CX, Functor, AX, AXBound> {
>Functor : Functor<CX, AX, AXBound>
>CX : CX
>_TX : _TX
>AXBound : AXBound
>Functor : Functor<CX, AX, AXBound>
>CX : CX
>AX : AX
>AXBound : AXBound
>AX : AX
>AXBound : AXBound
>AXBound : AXBound
>AX : AX
>Bounded : Bounded<BC, Bound, BT, BTBound>
>CX : CX
>Functor : Functor<CX, AX, AXBound>
>AX : AX
>AXBound : AXBound

    map<BX extends AXBound>(fmapx: (fmapxax: AX) => BX): CX<BX>;
>map : <BX extends AXBound>(fmapx: (fmapxax: AX) => BX) => CX
>BX : BX
>AXBound : AXBound
>fmapx : (fmapxax: AX) => BX
>fmapxax : AX
>AX : AX
>BX : BX
>CX : CX
>BX : BX
}

interface FunctorFoo<AFoo> extends Functor<FunctorFoo, AFoo> {
>FunctorFoo : FunctorFoo<AFoo>
>AFoo : AFoo
>Functor : Functor<CX, AX, AXBound>
>FunctorFoo : FunctorFoo<AFoo>
>AFoo : AFoo

    map<BFoo>(fmapfoo: FMap<AFoo, BFoo>): FunctorFoo<BFoo>;
>map : <BFoo>(fmapfoo: FMap<AFoo, BFoo>) => FunctorFoo<BFoo>
>BFoo : BFoo
>fmapfoo : FMap<AFoo, BFoo>
>FMap : FMap<FA, FB>
>AFoo : AFoo
>BFoo : BFoo
>FunctorFoo : FunctorFoo<AFoo>
>BFoo : BFoo

    fooVal: AFoo
>fooVal : AFoo
>AFoo : AFoo
}

interface StaticFunctor<
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>

    SC<_T extends SCTBound> extends SCBound<SC, _T> & Bounded<SC, SCBound, _T, SCTBound>,
>SC : SC
>_T : _T
>SCTBound : SCTBound
>SCBound : SCBound
>SC : SC
>_T : _T
>Bounded : Bounded<BC, Bound, BT, BTBound>
>SC : SC
>SCBound : SCBound
>_T : _T
>SCTBound : SCTBound

    SCBound<
>SCBound : SCBound

     _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

     _BT
>_BT : _BT

    >,
    SCTBound = {}
>SCTBound : SCTBound

> {
    <AS extends SCTBound, BS extends SCTBound>(fa2: SC<AS>, fmap2: FMap<AS,BS>): SC<BS>
>AS : AS
>SCTBound : SCTBound
>BS : BS
>SCTBound : SCTBound
>fa2 : SC
>SC : SC
>AS : AS
>fmap2 : FMap<AS, BS>
>FMap : FMap<FA, FB>
>AS : AS
>BS : BS
>SC : SC
>BS : BS
}


declare function staticMap<C1<_T1 extends T1Bound> extends Functor<C1, T1Bound, T1Bound>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1<A1>, fmap1: FMap<A1, B1>): C1<B1>;
>staticMap : <C1 extends Functor<C1, T1Bound, T1Bound>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1, fmap1: FMap<A1, B1>) => C1
>C1 : C1
>_T1 : _T1
>T1Bound : T1Bound
>Functor : Functor<CX, AX, AXBound>
>C1 : C1
>T1Bound : T1Bound
>T1Bound : T1Bound
>T1Bound : T1Bound
>A1 : A1
>T1Bound : T1Bound
>B1 : B1
>T1Bound : T1Bound
>fa1 : C1
>C1 : C1
>A1 : A1
>fmap1 : FMap<A1, B1>
>FMap : FMap<FA, FB>
>A1 : A1
>B1 : B1
>C1 : C1
>B1 : B1


interface LiftedResult<
>LiftedResult : LiftedResult<LC, LRCBound, LRTBound>

    LC<_LT extends LRTBound> extends LRCBound<LC, _LT> & Bounded<LC, LRCBound, _LT, LRTBound>,
>LC : LC
>_LT : _LT
>LRTBound : LRTBound
>LRCBound : LRCBound
>LC : LC
>_LT : _LT
>Bounded : Bounded<BC, Bound, BT, BTBound>
>LC : LC
>LRCBound : LRCBound
>_LT : _LT
>LRTBound : LRTBound

    LRCBound<
>LRCBound : LRCBound

    _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

    _BT
>_BT : _BT

   >,
   LRTBound 
>LRTBound : LRTBound

> {
    <LA, LB>(lmap: FMap<LA,LB>): LiftedResult2<LC, LA, LB, LRCBound>
>LA : LA
>LB : LB
>lmap : FMap<LA, LB>
>FMap : FMap<FA, FB>
>LA : LA
>LB : LB
>LiftedResult2 : LiftedResult2<LC2, LA2, LB2, LRC2Bound>
>LC : LC
>LA : LA
>LB : LB
>LRCBound : LRCBound
}

interface LiftedResult2<
>LiftedResult2 : LiftedResult2<LC2, LA2, LB2, LRC2Bound>

    LC2<_LT extends LA2 | LB2> extends LRC2Bound<LC2, _LT,  LA2 | LB2> & Bounded<LC2, LRC2Bound, _LT, LA2 | LB2>, 
>LC2 : LC2
>_LT : _LT
>LA2 : LA2
>LB2 : LB2
>LRC2Bound : LRC2Bound
>LC2 : LC2
>_LT : _LT
>LA2 : LA2
>LB2 : LB2
>Bounded : Bounded<BC, Bound, BT, BTBound>
>LC2 : LC2
>LRC2Bound : LRC2Bound
>_LT : _LT
>LA2 : LA2
>LB2 : LB2

    LA2,
>LA2 : LA2

    LB2,
>LB2 : LB2

    LRC2Bound<
>LRC2Bound : LRC2Bound

        _BC<__BCT>,
>_BC : _BC
>__BCT : __BCT

        _BT,
>_BT : _BT

        _BTB
>_BTB : _BTB

    >,
> {
    <FinalC<_FT extends LA2 | LB2> extends LC2<_FT>>(lc2la2: FinalC<LA2>): FinalC<LB2>
>FinalC : FinalC
>_FT : _FT
>LA2 : LA2
>LB2 : LB2
>LC2 : LC2
>_FT : _FT
>lc2la2 : FinalC
>FinalC : FinalC
>LA2 : LA2
>FinalC : FinalC
>LB2 : LB2
}

declare function lift<
>lift : <C extends ActBound & Bounded<C, ActBound, ActTBound, ActTBound>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>

    C<_T extends ActTBound> extends ActBound & Bounded<C, ActBound, _T, ActTBound>,
>C : C
>_T : _T
>ActTBound : ActTBound
>ActBound : ActBound
>Bounded : Bounded<BC, Bound, BT, BTBound>
>C : C
>ActBound : ActBound
>_T : _T
>ActTBound : ActTBound

    ActBound,
>ActBound : ActBound

    ActTBound
>ActTBound : ActTBound

>
(fToLift: StaticFunctor<C, ActBound, ActTBound>): LiftedResult<C, ActBound, ActTBound>
>fToLift : StaticFunctor<C, ActBound, ActTBound>
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>
>C : C
>ActBound : ActBound
>ActTBound : ActTBound
>LiftedResult : LiftedResult<LC, LRCBound, LRTBound>
>C : C
>ActBound : ActBound
>ActTBound : ActTBound

interface StartVal {
>StartVal : StartVal

    startVal: string
>startVal : string
}

interface EndVal {
>EndVal : EndVal

    endVal: number
>endVal : number
}


declare const fooObj: FunctorFoo<StartVal>
>fooObj : FunctorFoo<StartVal>
>FunctorFoo : FunctorFoo<AFoo>
>StartVal : StartVal

declare function stringLength(strarg: StartVal): EndVal
>stringLength : (strarg: StartVal) => EndVal
>strarg : StartVal
>StartVal : StartVal
>EndVal : EndVal

const liftedStaticMap = lift(staticMap);
>liftedStaticMap : LiftedResult<Functor<any, any, any>, {}, {}>
>lift(staticMap) : LiftedResult<Functor<any, any, any>, {}, {}>
>lift : <C extends ActBound & Bounded<C, ActBound, ActTBound, ActTBound>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>
>staticMap : <C1 extends Functor<C1, T1Bound, T1Bound>, T1Bound, A1 extends T1Bound, B1 extends T1Bound>(fa1: C1, fmap1: FMap<A1, B1>) => C1

const liftedStringLength = liftedStaticMap(stringLength);
>liftedStringLength : LiftedResult2<Functor<any, any, any>, StartVal, EndVal, {}>
>liftedStaticMap(stringLength) : LiftedResult2<Functor<any, any, any>, StartVal, EndVal, {}>
>liftedStaticMap : LiftedResult<Functor<any, any, any>, {}, {}>
>stringLength : (strarg: StartVal) => EndVal

const result = liftedStringLength(fooObj);
>result : FunctorFoo<EndVal>
>liftedStringLength(fooObj) : FunctorFoo<EndVal>
>liftedStringLength : LiftedResult2<Functor<any, any, any>, StartVal, EndVal, {}>
>fooObj : FunctorFoo<StartVal>

const expectedType: FunctorFoo<EndVal> = result;
>expectedType : FunctorFoo<EndVal>
>FunctorFoo : FunctorFoo<AFoo>
>EndVal : EndVal
>result : FunctorFoo<EndVal>

const expectError = liftedStringLength(result)
>expectError : any
>liftedStringLength(result) : any
>liftedStringLength : LiftedResult2<Functor<any, any, any>, StartVal, EndVal, {}>
>result : FunctorFoo<EndVal>


declare const declaredStaticFunctor: StaticFunctor<Functor, Functor>
>declaredStaticFunctor : StaticFunctor<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>StaticFunctor : StaticFunctor<SC, SCBound, SCTBound>
>Functor : Functor<CX, AX, AXBound>
>Functor : Functor<CX, AX, AXBound>

const liftedDeclaredStaticFunctor = lift(declaredStaticFunctor);
>liftedDeclaredStaticFunctor : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift(declaredStaticFunctor) : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>lift : <C extends ActBound & Bounded<C, ActBound, ActTBound, ActTBound>, ActBound, ActTBound>(fToLift: StaticFunctor<C, ActBound, ActTBound>) => LiftedResult<C, ActBound, ActTBound>
>declaredStaticFunctor : StaticFunctor<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>

const liftedDeclaredStringLength = liftedDeclaredStaticFunctor(stringLength)
>liftedDeclaredStringLength : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedDeclaredStaticFunctor(stringLength) : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>liftedDeclaredStaticFunctor : LiftedResult<Functor<CX, AX, AXBound>, Functor<CX, AX, AXBound>, {}>
>stringLength : (strarg: StartVal) => EndVal

const declaredResult = liftedDeclaredStringLength(fooObj);
>declaredResult : any
>liftedDeclaredStringLength(fooObj) : any
>liftedDeclaredStringLength : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>fooObj : FunctorFoo<StartVal>

const expectedTypeDeclared: FunctorFoo<EndVal> = declaredResult;
>expectedTypeDeclared : FunctorFoo<EndVal>
>FunctorFoo : FunctorFoo<AFoo>
>EndVal : EndVal
>declaredResult : any

const expectErrorDeclared = liftedDeclaredStringLength(declaredResult)
>expectErrorDeclared : FinalC
>liftedDeclaredStringLength(declaredResult) : FinalC
>liftedDeclaredStringLength : LiftedResult2<Functor<CX, AX, AXBound>, StartVal, EndVal, Functor<CX, AX, AXBound>>
>declaredResult : any

