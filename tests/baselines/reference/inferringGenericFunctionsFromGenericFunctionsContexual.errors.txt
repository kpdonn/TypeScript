tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts(8,23): error TS7006: Parameter 'x' implicitly has an 'any' type.
tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts(43,11): error TS2322: Type '<A>(x: A) => { boxed: A[]; }' is not assignable to type '<U>(u: U) => { boxed: U[]; }'.
  Type '{ boxed: A[]; }' is not assignable to type '{ boxed: U[]; }'.
    Types of property 'boxed' are incompatible.
      Type 'A[]' is not assignable to type 'U[]'.
        Type 'A' is not assignable to type 'U'.
tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts(45,11): error TS2322: Type '{ boxed: A[]; }' is not assignable to type '{ boxed: string[]; }'.
  Types of property 'boxed' are incompatible.
    Type 'A[]' is not assignable to type 'string[]'.
      Type 'A' is not assignable to type 'string'.


==== tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts (3 errors) ====
    export {}
    
    declare function identity1<T, U>(f: (t: T) => U): (t2: T) => U
    const id1 = identity1(x => x)
    
    
    declare function identity2<T>(f: T): T
    const id2 = identity2(x => x)
                          ~
!!! error TS7006: Parameter 'x' implicitly has an 'any' type.
    
    
    declare function identity3<T extends number, U>(f: (t: T) => U): (t2: T) => U
    const id3 = identity3(x => x)
    
    
    
    
    
    declare function compose<A, B, C>(f: (x: A) => B, g: (y: B) => C): (x: A) => C;
    
    {
        let composed1 = compose(x => x, x2 => x2)
        const expectedComposed1: <U>(u: U) => U = composed1;
        const callComposed1 = composed1("test");
        const expectedCallComposed1 : string = callComposed1;
    }
    
    {
        let composed2 = compose(x => x, x2 => [x2])
        const expectedComposed2: <U>(u: U) => U[] = composed2;
        const callComposed2 = composed2("test");
        const expectedCallComposed2: string[] = callComposed2;
    }
    
    {
        let composed3 = compose(x => [x], x2 => x2)
        const expectedComposed3: <U>(u: U) => U[] = composed3;
        const callComposed3 = composed3("test");
        const expectedCallComposed3 : string[] = callComposed3;
    }
    
    {
        let composed4 = compose(x => [x], x2 => ({ boxed: x2 }));
        const expectedComposed4: <U>(u: U) => {boxed: U[]} = composed4;
              ~~~~~~~~~~~~~~~~~
!!! error TS2322: Type '<A>(x: A) => { boxed: A[]; }' is not assignable to type '<U>(u: U) => { boxed: U[]; }'.
!!! error TS2322:   Type '{ boxed: A[]; }' is not assignable to type '{ boxed: U[]; }'.
!!! error TS2322:     Types of property 'boxed' are incompatible.
!!! error TS2322:       Type 'A[]' is not assignable to type 'U[]'.
!!! error TS2322:         Type 'A' is not assignable to type 'U'.
        const callComposed4 = composed4("test");
        const expectedCallComposed4 : {boxed: string[]} = callComposed4;
              ~~~~~~~~~~~~~~~~~~~~~
!!! error TS2322: Type '{ boxed: A[]; }' is not assignable to type '{ boxed: string[]; }'.
!!! error TS2322:   Types of property 'boxed' are incompatible.
!!! error TS2322:     Type 'A[]' is not assignable to type 'string[]'.
!!! error TS2322:       Type 'A' is not assignable to type 'string'.
    }
    