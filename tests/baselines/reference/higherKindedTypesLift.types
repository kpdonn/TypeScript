=== tests/cases/compiler/higherKindedTypesLift.ts ===
export interface Functor<AF, Container<_TF>> {
>Functor : Functor<AF, Container<_TF>>
>AF : AF
>Container : Container<_TF>
>_TF : _TF

    map<BF>(f: (a: AF) => BF): Container<BF>;
>map : <BF>(f: (a: AF) => BF) => Container<BF>
>BF : BF
>f : (a: AF) => BF
>a : AF
>AF : AF
>BF : BF
>Container : Container<_TF>
>BF : BF
}

class FunctorX<AX> implements Functor<AX, FunctorX> {
>FunctorX : FunctorX<AX>
>AX : AX
>Functor : Functor<AF, Container<_TF>>
>AX : AX
>FunctorX : FunctorX<AX>

    constructor(private elements: AX[]) {}
>elements : AX[]
>AX : AX

    map<BX>(f: (a: AX) => BX): FunctorX<BX> {
>map : <BX>(f: (a: AX) => BX) => FunctorX<BX>
>BX : BX
>f : (a: AX) => BX
>a : AX
>AX : AX
>BX : BX
>FunctorX : FunctorX<AX>
>BX : BX

        const mappedElements = this.elements.map(f);
>mappedElements : BX[]
>this.elements.map(f) : BX[]
>this.elements.map : <U>(callbackfn: (value: AX, index: number, array: AX[]) => U, thisArg?: any) => U[]
>this.elements : AX[]
>this : this
>elements : AX[]
>map : <U>(callbackfn: (value: AX, index: number, array: AX[]) => U, thisArg?: any) => U[]
>f : (a: AX) => BX

        return new FunctorX(mappedElements);
>new FunctorX(mappedElements) : FunctorX<BX>
>FunctorX : typeof FunctorX
>mappedElements : BX[]
    }

    firstVal(): AX | undefined {
>firstVal : () => AX | undefined
>AX : AX

        return this.elements.length ? this.elements[0] : undefined;
>this.elements.length ? this.elements[0] : undefined : AX | undefined
>this.elements.length : number
>this.elements : AX[]
>this : this
>elements : AX[]
>length : number
>this.elements[0] : AX
>this.elements : AX[]
>this : this
>elements : AX[]
>0 : 0
>undefined : undefined

    };
}


interface StaticFunctor<CS<_TS>> {
>StaticFunctor : StaticFunctor<CS<_TS>>
>CS : CS<_TS>
>_TS : _TS

    <AS, BS>(csas: CS<AS>, fmapstatic: (as: AS) => BS): CS<BS>;
>AS : AS
>BS : BS
>csas : CS<AS>
>CS : CS<_TS>
>AS : AS
>fmapstatic : (as: AS) => BS
>as : AS
>AS : AS
>BS : BS
>CS : CS<_TS>
>BS : BS
}


interface LiftedResult<LRC<_LT>> {
>LiftedResult : LiftedResult<LRC<_LT>>
>LRC : LRC<_LT>
>_LT : _LT

    <LRA, LRB>(lrmap: (lra: LRA) => LRB): <NC<_NT> extends LRC<_NT>>(lrclra: NC<LRA>) => NC<LRB>
>LRA : LRA
>LRB : LRB
>lrmap : (lra: LRA) => LRB
>lra : LRA
>LRA : LRA
>LRB : LRB
>NC : NC<_NT>
>_NT : _NT
>LRC : LRC<_LT>
>_NT : _NT
>lrclra : NC<LRA>
>NC : NC<_NT>
>LRA : LRA
>NC : NC<_NT>
>LRB : LRB
}

function lift<C<_TL>>(fToLift: StaticFunctor<C>): LiftedResult<C> {
>lift : <C>(fToLift: StaticFunctor<C<_TS>>) => LiftedResult<C<_LT>>
>C : C<_TL>
>_TL : _TL
>fToLift : StaticFunctor<C<_TS>>
>StaticFunctor : StaticFunctor<CS<_TS>>
>C : C<_TL>
>LiftedResult : LiftedResult<LRC<_LT>>
>C : C<_TL>

    return lmap => lca => fToLift(lca, lmap);
>lmap => lca => fToLift(lca, lmap) : <LRA, LRB>(lmap: (lra: LRA) => LRB) => <NC extends C<_NT>>(lca: LiftedResult<C<_LT>>.NC<LRA>) => C<LRB>
>lmap : (lra: LRA) => LRB
>lca => fToLift(lca, lmap) : <NC extends C<_NT>>(lca: LiftedResult<C<_LT>>.NC<LRA>) => C<LRB>
>lca : LiftedResult<C<_LT>>.NC<LRA>
>fToLift(lca, lmap) : C<LRB>
>fToLift : StaticFunctor<C<_TS>>
>lca : LiftedResult<C<_LT>>.NC<LRA>
>lmap : (lra: LRA) => LRB
}

function staticMap<C1<_T1> extends Functor<_T1, C1>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1): C1<B1> {
>staticMap : <C1 extends Functor<_T1, C1<_TF>>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1) => C1<B1>
>C1 : C1<_T1>
>_T1 : _T1
>Functor : Functor<AF, Container<_TF>>
>_T1 : _T1
>C1 : C1<_T1>
>A1 : A1
>B1 : B1
>fa1 : C1<A1>
>C1 : C1<_T1>
>A1 : A1
>fmap1 : (a1: A1) => B1
>a1 : A1
>A1 : A1
>B1 : B1
>C1 : C1<_T1>
>B1 : B1

    return fa1.map(fmap1);
>fa1.map(fmap1) : C1<B1>
>fa1.map : <BF>(f: (a: A1) => BF) => C1<BF>
>fa1 : C1<A1>
>map : <BF>(f: (a: A1) => BF) => C1<BF>
>fmap1 : (a1: A1) => B1
}

const liftedFunctor = lift(staticMap);
>liftedFunctor : LiftedResult<C1<_LT>>
>lift(staticMap) : LiftedResult<C1<_LT>>
>lift : <C>(fToLift: StaticFunctor<C<_TS>>) => LiftedResult<C<_LT>>
>staticMap : <C1 extends Functor<_T1, C1<_TF>>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1) => C1<B1>

function stringLength(strarg: string): number {
>stringLength : (strarg: string) => number
>strarg : string

    return strarg.length;
>strarg.length : number
>strarg : string
>length : number
}

const liftedStringLength = liftedFunctor(stringLength);
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>liftedFunctor(stringLength) : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>liftedFunctor : LiftedResult<C1<_LT>>
>stringLength : (strarg: string) => number

const functorXString = new FunctorX(["myFunctorX"]);
>functorXString : FunctorX<string>
>new FunctorX(["myFunctorX"]) : FunctorX<string>
>FunctorX : typeof FunctorX
>["myFunctorX"] : string[]
>"myFunctorX" : "myFunctorX"

const result = liftedStringLength(functorXString);
>result : FunctorX<number>
>liftedStringLength(functorXString) : FunctorX<number>
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>functorXString : FunctorX<string>

const expectedType: FunctorX<number> = result;
>expectedType : FunctorX<number>
>FunctorX : FunctorX<AX>
>result : FunctorX<number>

const expectError = liftedStringLength(result);
>expectError : any
>liftedStringLength(result) : any
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>result : FunctorX<number>



export interface DiffFunctor<DA, DContainer<_TD>> {
>DiffFunctor : DiffFunctor<DA, DContainer<_TD>>
>DA : DA
>DContainer : DContainer<_TD>
>_TD : _TD

    diffMap<DB>(df: (da: DA) => DB): DContainer<DB>;
>diffMap : <DB>(df: (da: DA) => DB) => DContainer<DB>
>DB : DB
>df : (da: DA) => DB
>da : DA
>DA : DA
>DB : DB
>DContainer : DContainer<_TD>
>DB : DB
}

declare class DiffFunctorY<AY> implements DiffFunctor<AY, DiffFunctorY> {
>DiffFunctorY : DiffFunctorY<AY>
>AY : AY
>DiffFunctor : DiffFunctor<DA, DContainer<_TD>>
>AY : AY
>DiffFunctorY : DiffFunctorY<AY>

    diffMap<BY>(f: (a: AY) => BY): DiffFunctorY<BY>
>diffMap : <BY>(f: (a: AY) => BY) => DiffFunctorY<BY>
>BY : BY
>f : (a: AY) => BY
>a : AY
>AY : AY
>BY : BY
>DiffFunctorY : DiffFunctorY<AY>
>BY : BY

    firstValY(): AY | undefined
>firstValY : () => AY | undefined
>AY : AY
}

declare const diffFunctorYString: DiffFunctorY<string>;
>diffFunctorYString : DiffFunctorY<string>
>DiffFunctorY : DiffFunctorY<AY>

// should have error because DiffFunctorY has diffMap function, not "map" as needed because liftedFunctor was created from staticMap which declared Functor
const expectError2 = liftedStringLength(diffFunctorYString);
>expectError2 : any
>liftedStringLength(diffFunctorYString) : any
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>diffFunctorYString : DiffFunctorY<string>


declare class InvalidFunctor<IA> {
>InvalidFunctor : InvalidFunctor<IA>
>IA : IA

    // does not actually implement Functor because it doesn't return InvalidFunctor<IB>
    map<IB>(fi: (ia: IA) => IB): IB
>map : <IB>(fi: (ia: IA) => IB) => IB
>IB : IB
>fi : (ia: IA) => IB
>ia : IA
>IA : IA
>IB : IB
>IB : IB
}

declare const invalidFunctor: InvalidFunctor<string>;
>invalidFunctor : InvalidFunctor<string>
>InvalidFunctor : InvalidFunctor<IA>

const expectError3 = liftedStringLength(invalidFunctor);
>expectError3 : any
>liftedStringLength(invalidFunctor) : any
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>invalidFunctor : InvalidFunctor<string>



declare class InvalidFunctor2<IA2> {
>InvalidFunctor2 : InvalidFunctor2<IA2>
>IA2 : IA2

    // does not actually implement Functor because it doesn't return InvalidFunctor2<IB>
    map<IB2>(fi2: (ia2: IA2) => IB2): FunctorX<IB2>
>map : <IB2>(fi2: (ia2: IA2) => IB2) => FunctorX<IB2>
>IB2 : IB2
>fi2 : (ia2: IA2) => IB2
>ia2 : IA2
>IA2 : IA2
>IB2 : IB2
>FunctorX : FunctorX<AX>
>IB2 : IB2

    someUniqueMethod(): IA2
>someUniqueMethod : () => IA2
>IA2 : IA2
}

declare const invalidFunctor2: InvalidFunctor2<string>;
>invalidFunctor2 : InvalidFunctor2<string>
>InvalidFunctor2 : InvalidFunctor2<IA2>

const expectError4 = liftedStringLength(invalidFunctor2);
>expectError4 : any
>liftedStringLength(invalidFunctor2) : any
>liftedStringLength : <NC extends C1<_NT>>(lrclra: LiftedResult<C1<_LT>>.NC<string>) => LiftedResult<C1<_LT>>.NC<number>
>invalidFunctor2 : InvalidFunctor2<string>

