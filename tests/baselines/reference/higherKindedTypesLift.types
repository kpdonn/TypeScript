=== tests/cases/compiler/higherKindedTypesLift.ts ===
declare function stringLength(strarg: string): number;
>stringLength : (strarg: string) => number
>strarg : string

export interface Functor<AF, Container<_TF>> {
>Functor : Functor<AF, Container>
>AF : AF
>Container : Container
>_TF : _TF

    map<BF>(f: (a: AF) => BF): Container<BF>;
>map : <BF>(f: (a: AF) => BF) => Container
>BF : BF
>f : (a: AF) => BF
>a : AF
>AF : AF
>BF : BF
>Container : Container
>BF : BF
}

export interface DiffFunctor<DA, DContainer<_TD>> {
>DiffFunctor : DiffFunctor<DA, DContainer>
>DA : DA
>DContainer : DContainer
>_TD : _TD

    diffMap<DB>(df: (da: DA) => DB): DContainer<DB>;
>diffMap : <DB>(df: (da: DA) => DB) => DContainer
>DB : DB
>df : (da: DA) => DB
>da : DA
>DA : DA
>DB : DB
>DContainer : DContainer
>DB : DB
}

class FunctorX<AX> implements Functor<AX, FunctorX> {
>FunctorX : FunctorX<AX>
>AX : AX
>Functor : Functor<AF, Container>
>AX : AX
>FunctorX : FunctorX<AX>

    constructor(private elements: AX[]) {}
>elements : AX[]
>AX : AX

    map<BX>(f: (a: AX) => BX): FunctorX<BX> {
>map : <BX>(f: (a: AX) => BX) => FunctorX<BX>
>BX : BX
>f : (a: AX) => BX
>a : AX
>AX : AX
>BX : BX
>FunctorX : FunctorX<AX>
>BX : BX

        const mappedElements = this.elements.map(f);
>mappedElements : BX[]
>this.elements.map(f) : BX[]
>this.elements.map : <U>(callbackfn: (value: AX, index: number, array: AX[]) => U, thisArg?: any) => U[]
>this.elements : AX[]
>this : this
>elements : AX[]
>map : <U>(callbackfn: (value: AX, index: number, array: AX[]) => U, thisArg?: any) => U[]
>f : (a: AX) => BX

        return new FunctorX(mappedElements);
>new FunctorX(mappedElements) : FunctorX<BX>
>FunctorX : typeof FunctorX
>mappedElements : BX[]
    }

    firstVal(): AX | undefined {
>firstVal : () => AX | undefined
>AX : AX

        return this.elements.length ? this.elements[0] : undefined;
>this.elements.length ? this.elements[0] : undefined : AX | undefined
>this.elements.length : number
>this.elements : AX[]
>this : this
>elements : AX[]
>length : number
>this.elements[0] : AX
>this.elements : AX[]
>this : this
>elements : AX[]
>0 : 0
>undefined : undefined

    };
}

const functorXString = new FunctorX(["myFunctorX"]);
>functorXString : FunctorX<string>
>new FunctorX(["myFunctorX"]) : FunctorX<string>
>FunctorX : typeof FunctorX
>["myFunctorX"] : string[]
>"myFunctorX" : "myFunctorX"

declare class DiffFunctorY<AY> implements DiffFunctor<AY, DiffFunctorY> {
>DiffFunctorY : DiffFunctorY<AY>
>AY : AY
>DiffFunctor : DiffFunctor<DA, DContainer>
>AY : AY
>DiffFunctorY : DiffFunctorY<AY>

    diffMap<BY>(f: (a: AY) => BY): DiffFunctorY<BY>
>diffMap : <BY>(f: (a: AY) => BY) => DiffFunctorY<BY>
>BY : BY
>f : (a: AY) => BY
>a : AY
>AY : AY
>BY : BY
>DiffFunctorY : DiffFunctorY<AY>
>BY : BY

    firstValY(): AY | undefined
>firstValY : () => AY | undefined
>AY : AY
}

declare const diffFunctorYString: DiffFunctorY<string>;
>diffFunctorYString : DiffFunctorY<string>
>DiffFunctorY : DiffFunctorY<AY>

declare class InvalidFunctor<IA> {
>InvalidFunctor : InvalidFunctor<IA>
>IA : IA

    // does not actually implement Functor because it doesn't return InvalidFunctor<IB>
    map<IB>(fi: (ia: IA) => IB): IB
>map : <IB>(fi: (ia: IA) => IB) => IB
>IB : IB
>fi : (ia: IA) => IB
>ia : IA
>IA : IA
>IB : IB
>IB : IB
}
declare const invalidFunctor: InvalidFunctor<string>;
>invalidFunctor : InvalidFunctor<string>
>InvalidFunctor : InvalidFunctor<IA>

declare class InvalidFunctor2<IA2> {
>InvalidFunctor2 : InvalidFunctor2<IA2>
>IA2 : IA2

    // does not actually implement Functor because it doesn't return InvalidFunctor2<IB>
    map<IB2>(fi2: (ia2: IA2) => IB2): FunctorX<IB2>
>map : <IB2>(fi2: (ia2: IA2) => IB2) => FunctorX<IB2>
>IB2 : IB2
>fi2 : (ia2: IA2) => IB2
>ia2 : IA2
>IA2 : IA2
>IB2 : IB2
>FunctorX : FunctorX<AX>
>IB2 : IB2

    someUniqueMethod(): IA2
>someUniqueMethod : () => IA2
>IA2 : IA2
}
declare const invalidFunctor2: InvalidFunctor2<string>;
>invalidFunctor2 : InvalidFunctor2<string>
>InvalidFunctor2 : InvalidFunctor2<IA2>

interface StaticFunctor<CS<_TS>> {
>StaticFunctor : StaticFunctor<CS>
>CS : CS
>_TS : _TS

    <AS, BS>(csas: CS<AS>, fmapstatic: (as: AS) => BS): CS<BS>;
>AS : AS
>BS : BS
>csas : CS
>CS : CS
>AS : AS
>fmapstatic : (as: AS) => BS
>as : AS
>AS : AS
>BS : BS
>CS : CS
>BS : BS
}

interface LiftedResult<LRC<_LT>> {
>LiftedResult : LiftedResult<LRC>
>LRC : LRC
>_LT : _LT

    <LRA, LRB>(lrmap: (lra: LRA) => LRB): <NC<_NT> extends LRC<_NT>>(lrclra: NC<LRA>) => NC<LRB>
>LRA : LRA
>LRB : LRB
>lrmap : (lra: LRA) => LRB
>lra : LRA
>LRA : LRA
>LRB : LRB
>NC : NC
>_NT : _NT
>LRC : LRC
>_NT : _NT
>lrclra : NC
>NC : NC
>LRA : LRA
>NC : NC
>LRB : LRB
}

interface LiftedResult3A<LRC<_LT>> {
>LiftedResult3A : LiftedResult3A<LRC>
>LRC : LRC
>_LT : _LT

    <LRA, LRB>(lrmap: (lra: LRA) => LRB): LiftedResult3B<LRC, LRA, LRB>
>LRA : LRA
>LRB : LRB
>lrmap : (lra: LRA) => LRB
>lra : LRA
>LRA : LRA
>LRB : LRB
>LiftedResult3B : LiftedResult3B<LRC, LRA, LRB>
>LRC : LRC
>LRA : LRA
>LRB : LRB
}
interface LiftedResult3B<LRC<_LT>, LRA, LRB> {
>LiftedResult3B : LiftedResult3B<LRC, LRA, LRB>
>LRC : LRC
>_LT : _LT
>LRA : LRA
>LRB : LRB

    <NC<_NT> extends LRC<_NT>>(lrclra: NC<LRA>): NC<LRB>
>NC : NC
>_NT : _NT
>LRC : LRC
>_NT : _NT
>lrclra : NC
>NC : NC
>LRA : LRA
>NC : NC
>LRB : LRB
}

function lift1<C<_TL>>(fToLift: StaticFunctor<C>): LiftedResult<C> {
>lift1 : <C>(fToLift: StaticFunctor<C>) => LiftedResult<C>
>C : C
>_TL : _TL
>fToLift : StaticFunctor<C>
>StaticFunctor : StaticFunctor<CS>
>C : C
>LiftedResult : LiftedResult<LRC>
>C : C

    return lmap => lca => fToLift(lca, lmap);
>lmap => lca => fToLift(lca, lmap) : <LRA, LRB>(lmap: (lra: LRA) => LRB) => <NC extends C>(lca: NC) => C
>lmap : (lra: LRA) => LRB
>lca => fToLift(lca, lmap) : <NC extends C>(lca: NC) => C
>lca : NC
>fToLift(lca, lmap) : C
>fToLift : StaticFunctor<C>
>lca : NC
>lmap : (lra: LRA) => LRB
}

// lift2 does not use intermediate interfaces
function lift2<C<_TL>>(
>lift2 : <C>(fToLift: <AS, BS>(csas: C, fmapstatic: (as: AS) => BS) => C) => <LA, LB>(lrmap: (lra: LA) => LB) => <NC extends C>(lrclra: NC) => NC
>C : C
>_TL : _TL

    fToLift: <AS, BS>(csas: C<AS>, fmapstatic: (as: AS) => BS) => C<BS>
>fToLift : <AS, BS>(csas: C, fmapstatic: (as: AS) => BS) => C
>AS : AS
>BS : BS
>csas : C
>C : C
>AS : AS
>fmapstatic : (as: AS) => BS
>as : AS
>AS : AS
>BS : BS
>C : C
>BS : BS

): 
    <LA, LB>(lrmap: (lra: LA) => LB) => <NC<_NT> extends C<_NT>>(lrclra: NC<LA>) => NC<LB> {
>LA : LA
>LB : LB
>lrmap : (lra: LA) => LB
>lra : LA
>LA : LA
>LB : LB
>NC : NC
>_NT : _NT
>C : C
>_NT : _NT
>lrclra : NC
>NC : NC
>LA : LA
>NC : NC
>LB : LB

    return lmap => lca => fToLift(lca, lmap);
>lmap => lca => fToLift(lca, lmap) : <LA, LB>(lmap: (lra: LA) => LB) => <NC extends C>(lca: NC) => C
>lmap : (lra: LA) => LB
>lca => fToLift(lca, lmap) : <NC extends C>(lca: NC) => C
>lca : NC
>fToLift(lca, lmap) : C
>fToLift : <AS, BS>(csas: C, fmapstatic: (as: AS) => BS) => C
>lca : NC
>lmap : (lra: LA) => LB
}

// lift3 uses an extra intermediate interface
function lift3<C<_TL>>(fToLift: StaticFunctor<C>): LiftedResult3A<C> {
>lift3 : <C>(fToLift: StaticFunctor<C>) => LiftedResult3A<C>
>C : C
>_TL : _TL
>fToLift : StaticFunctor<C>
>StaticFunctor : StaticFunctor<CS>
>C : C
>LiftedResult3A : LiftedResult3A<LRC>
>C : C

    return lmap => lca => fToLift(lca, lmap);
>lmap => lca => fToLift(lca, lmap) : <LRA, LRB>(lmap: (lra: LRA) => LRB) => <NC extends C>(lca: NC) => C
>lmap : (lra: LRA) => LRB
>lca => fToLift(lca, lmap) : <NC extends C>(lca: NC) => C
>lca : NC
>fToLift(lca, lmap) : C
>fToLift : StaticFunctor<C>
>lca : NC
>lmap : (lra: LRA) => LRB
}

function staticMap<C1<_T1> extends Functor<_T1, C1>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1): C1<B1> {
>staticMap : <C1 extends Functor<{}, C1>, A1, B1>(fa1: C1, fmap1: (a1: A1) => B1) => C1
>C1 : C1
>_T1 : _T1
>Functor : Functor<AF, Container>
>_T1 : _T1
>C1 : C1
>A1 : A1
>B1 : B1
>fa1 : C1
>C1 : C1
>A1 : A1
>fmap1 : (a1: A1) => B1
>a1 : A1
>A1 : A1
>B1 : B1
>C1 : C1
>B1 : B1

    return fa1.map(fmap1);
>fa1.map(fmap1) : C1
>fa1.map : <BF>(f: (a: A1) => BF) => C1
>fa1 : C1
>map : <BF>(f: (a: A1) => BF) => C1
>fmap1 : (a1: A1) => B1
}

const liftedFunctor1 = lift1(staticMap);
>liftedFunctor1 : any
>lift1(staticMap) : any
>lift1 : <C>(fToLift: StaticFunctor<C>) => LiftedResult<C>
>staticMap : <C1 extends Functor<{}, C1>, A1, B1>(fa1: C1, fmap1: (a1: A1) => B1) => C1

const liftedFunctor2 = lift2(staticMap);
>liftedFunctor2 : any
>lift2(staticMap) : any
>lift2 : <C>(fToLift: <AS, BS>(csas: C, fmapstatic: (as: AS) => BS) => C) => <LA, LB>(lrmap: (lra: LA) => LB) => <NC extends C>(lrclra: NC) => NC
>staticMap : <C1 extends Functor<{}, C1>, A1, B1>(fa1: C1, fmap1: (a1: A1) => B1) => C1

const liftedFunctor3 = lift3(staticMap);
>liftedFunctor3 : any
>lift3(staticMap) : any
>lift3 : <C>(fToLift: StaticFunctor<C>) => LiftedResult3A<C>
>staticMap : <C1 extends Functor<{}, C1>, A1, B1>(fa1: C1, fmap1: (a1: A1) => B1) => C1

const liftedStringLength1 = liftedFunctor1(stringLength);
>liftedStringLength1 : any
>liftedFunctor1(stringLength) : any
>liftedFunctor1 : any
>stringLength : (strarg: string) => number

const liftedStringLength2 = liftedFunctor2(stringLength);
>liftedStringLength2 : any
>liftedFunctor2(stringLength) : any
>liftedFunctor2 : any
>stringLength : (strarg: string) => number

const liftedStringLength3 = liftedFunctor3(stringLength);
>liftedStringLength3 : any
>liftedFunctor3(stringLength) : any
>liftedFunctor3 : any
>stringLength : (strarg: string) => number


const result1 = liftedStringLength1(functorXString);
>result1 : any
>liftedStringLength1(functorXString) : any
>liftedStringLength1 : any
>functorXString : FunctorX<string>

const expectedType1: FunctorX<number> = result1;
>expectedType1 : FunctorX<number>
>FunctorX : FunctorX<AX>
>result1 : any

const result2 = liftedStringLength2(functorXString);
>result2 : any
>liftedStringLength2(functorXString) : any
>liftedStringLength2 : any
>functorXString : FunctorX<string>

const expectedType2: FunctorX<number> = result2;
>expectedType2 : FunctorX<number>
>FunctorX : FunctorX<AX>
>result2 : any

const result3 = liftedStringLength3(functorXString);
>result3 : any
>liftedStringLength3(functorXString) : any
>liftedStringLength3 : any
>functorXString : FunctorX<string>

const expectedType3: FunctorX<number> = result3;
>expectedType3 : FunctorX<number>
>FunctorX : FunctorX<AX>
>result3 : any

const expectErrorA1 = liftedStringLength1(result1);
>expectErrorA1 : any
>liftedStringLength1(result1) : any
>liftedStringLength1 : any
>result1 : any

const expectErrorA2 = liftedStringLength2(result2);
>expectErrorA2 : any
>liftedStringLength2(result2) : any
>liftedStringLength2 : any
>result2 : any

const expectErrorA3 = liftedStringLength3(result3);
>expectErrorA3 : any
>liftedStringLength3(result3) : any
>liftedStringLength3 : any
>result3 : any


const stringArray = ["not explicitly declared to implement functor"];
>stringArray : string[]
>["not explicitly declared to implement functor"] : string[]
>"not explicitly declared to implement functor" : "not explicitly declared to implement functor"

const arrayResult1 = liftedStringLength1(stringArray);
>arrayResult1 : any
>liftedStringLength1(stringArray) : any
>liftedStringLength1 : any
>stringArray : string[]

const arrayExpectedType1: Array<number> = arrayResult1;
>arrayExpectedType1 : number[]
>Array : T[]
>arrayResult1 : any

const arrayResult2 = liftedStringLength2(stringArray);
>arrayResult2 : any
>liftedStringLength2(stringArray) : any
>liftedStringLength2 : any
>stringArray : string[]

const arrayExpectedType2: Array<number> = arrayResult2;
>arrayExpectedType2 : number[]
>Array : T[]
>arrayResult2 : any

const arrayResult3 = liftedStringLength3(stringArray);
>arrayResult3 : any
>liftedStringLength3(stringArray) : any
>liftedStringLength3 : any
>stringArray : string[]

const arrayExpectedType3: Array<number> = arrayResult3;
>arrayExpectedType3 : number[]
>Array : T[]
>arrayResult3 : any

const arrayExpectErrorA1 = liftedStringLength1(arrayResult1);
>arrayExpectErrorA1 : any
>liftedStringLength1(arrayResult1) : any
>liftedStringLength1 : any
>arrayResult1 : any

const arrayExpectErrorA2 = liftedStringLength2(arrayResult2);
>arrayExpectErrorA2 : any
>liftedStringLength2(arrayResult2) : any
>liftedStringLength2 : any
>arrayResult2 : any

const arrayExpectErrorA3 = liftedStringLength3(arrayResult3);
>arrayExpectErrorA3 : any
>liftedStringLength3(arrayResult3) : any
>liftedStringLength3 : any
>arrayResult3 : any



// should have error because DiffFunctorY has diffMap function, not "map" as needed because liftedFunctor was created from staticMap which declared Functor
const expectErrorB1 = liftedStringLength1(diffFunctorYString);
>expectErrorB1 : any
>liftedStringLength1(diffFunctorYString) : any
>liftedStringLength1 : any
>diffFunctorYString : DiffFunctorY<string>

const expectErrorB2 = liftedStringLength2(diffFunctorYString);
>expectErrorB2 : any
>liftedStringLength2(diffFunctorYString) : any
>liftedStringLength2 : any
>diffFunctorYString : DiffFunctorY<string>

const expectErrorB3 = liftedStringLength3(diffFunctorYString);
>expectErrorB3 : any
>liftedStringLength3(diffFunctorYString) : any
>liftedStringLength3 : any
>diffFunctorYString : DiffFunctorY<string>


const expectErrorC1 = liftedStringLength1(invalidFunctor);
>expectErrorC1 : any
>liftedStringLength1(invalidFunctor) : any
>liftedStringLength1 : any
>invalidFunctor : InvalidFunctor<string>

const expectErrorC2 = liftedStringLength2(invalidFunctor);
>expectErrorC2 : any
>liftedStringLength2(invalidFunctor) : any
>liftedStringLength2 : any
>invalidFunctor : InvalidFunctor<string>

const expectErrorC3 = liftedStringLength3(invalidFunctor);
>expectErrorC3 : any
>liftedStringLength3(invalidFunctor) : any
>liftedStringLength3 : any
>invalidFunctor : InvalidFunctor<string>


const expectErrorD1 = liftedStringLength1(invalidFunctor2);
>expectErrorD1 : any
>liftedStringLength1(invalidFunctor2) : any
>liftedStringLength1 : any
>invalidFunctor2 : InvalidFunctor2<string>

const expectErrorD2 = liftedStringLength2(invalidFunctor2);
>expectErrorD2 : any
>liftedStringLength2(invalidFunctor2) : any
>liftedStringLength2 : any
>invalidFunctor2 : InvalidFunctor2<string>

const expectErrorD3 = liftedStringLength3(invalidFunctor2);
>expectErrorD3 : any
>liftedStringLength3(invalidFunctor2) : any
>liftedStringLength3 : any
>invalidFunctor2 : InvalidFunctor2<string>

