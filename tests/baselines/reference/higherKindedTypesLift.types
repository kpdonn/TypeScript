=== tests/cases/compiler/higherKindedTypesLift.ts ===
export interface Functor<A, Container<_T>> {
>Functor : Functor<A, Container<_T>>
>A : A
>Container : Container<_T>
>_T : _T

    map<B>(f: (a: A) => B): Container<B>;
>map : <B>(f: (a: A) => B) => Container<B>
>B : B
>f : (a: A) => B
>a : A
>A : A
>B : B
>Container : Container<_T>
>B : B
}

class FunctorX<A> implements Functor<A, FunctorX> {
>FunctorX : FunctorX<A>
>A : A
>Functor : Functor<A, Container<_T>>
>A : A
>FunctorX : FunctorX<A>

    constructor(private elements: A[]) {}
>elements : A[]
>A : A

    map<B>(f: (a: A) => B): FunctorX<B> {
>map : <B>(f: (a: A) => B) => FunctorX<B>
>B : B
>f : (a: A) => B
>a : A
>A : A
>B : B
>FunctorX : FunctorX<A>
>B : B

        const mappedElements = this.elements.map(f);
>mappedElements : B[]
>this.elements.map(f) : B[]
>this.elements.map : <U>(callbackfn: (value: A, index: number, array: A[]) => U, thisArg?: any) => U[]
>this.elements : A[]
>this : this
>elements : A[]
>map : <U>(callbackfn: (value: A, index: number, array: A[]) => U, thisArg?: any) => U[]
>f : (a: A) => B

        return new FunctorX(mappedElements);
>new FunctorX(mappedElements) : FunctorX<B>
>FunctorX : typeof FunctorX
>mappedElements : B[]
    }

    firstVal(): A | undefined {
>firstVal : () => A | undefined
>A : A

        return this.elements.length ? this.elements[0] : undefined;
>this.elements.length ? this.elements[0] : undefined : A | undefined
>this.elements.length : number
>this.elements : A[]
>this : this
>elements : A[]
>length : number
>this.elements[0] : A
>this.elements : A[]
>this : this
>elements : A[]
>0 : 0
>undefined : undefined

    };
}


interface StaticFunctor<CS<_TS>> {
>StaticFunctor : StaticFunctor<CS<_TS>>
>CS : CS<_TS>
>_TS : _TS

    <AS, BS>(csas: CS<AS>, fmapstatic: (as: AS) => BS): CS<BS>;
>AS : AS
>BS : BS
>csas : CS<AS>
>CS : CS<_TS>
>AS : AS
>fmapstatic : (as: AS) => BS
>as : AS
>AS : AS
>BS : BS
>CS : CS<_TS>
>BS : BS
}


interface LiftedResult<LRC<_LT>> {
>LiftedResult : LiftedResult<LRC<_LT>>
>LRC : LRC<_LT>
>_LT : _LT

    <LRA, LRB>(lrmap: (lra: LRA) => LRB): <NC<_NT> extends LRC<_NT>>(lrclra: NC<LRA>) => NC<LRB>
>LRA : LRA
>LRB : LRB
>lrmap : (lra: LRA) => LRB
>lra : LRA
>LRA : LRA
>LRB : LRB
>NC : NC<_NT>
>_NT : _NT
>LRC : LRC<_LT>
>_NT : _NT
>lrclra : NC<LRA>
>NC : NC<_NT>
>LRA : LRA
>NC : NC<_NT>
>LRB : LRB
}

function lift<C<_T>>(fToLift: StaticFunctor<C>): LiftedResult<C> {
>lift : <C>(fToLift: StaticFunctor<C<_T>>) => LiftedResult<C<_T>>
>C : C<_T>
>_T : _T
>fToLift : StaticFunctor<C<_T>>
>StaticFunctor : StaticFunctor<CS<_TS>>
>C : C<_T>
>LiftedResult : LiftedResult<LRC<_LT>>
>C : C<_T>

    return lmap => lca => fToLift(lca, lmap);
>lmap => lca => fToLift(lca, lmap) : <LRA, LRB>(lmap: (lra: LRA) => LRB) => <NC extends LRC<_NT>>(lca: NC<LRA>) => C<LRB>
>lmap : (lra: LRA) => LRB
>lca => fToLift(lca, lmap) : <NC extends LRC<_NT>>(lca: NC<LRA>) => C<LRB>
>lca : NC<LRA>
>fToLift(lca, lmap) : C<LRB>
>fToLift : StaticFunctor<C<_T>>
>lca : NC<LRA>
>lmap : (lra: LRA) => LRB
}

function staticMap<C1<_T1> extends Functor<_T1, C1>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1): C1<B1> {
>staticMap : <C1 extends Functor<_T1, C1<_T1>>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1) => C1<B1>
>C1 : C1<_T1>
>_T1 : _T1
>Functor : Functor<A, Container<_T>>
>_T1 : _T1
>C1 : C1<_T1>
>A1 : A1
>B1 : B1
>fa1 : C1<A1>
>C1 : C1<_T1>
>A1 : A1
>fmap1 : (a1: A1) => B1
>a1 : A1
>A1 : A1
>B1 : B1
>C1 : C1<_T1>
>B1 : B1

    return fa1.map(fmap1);
>fa1.map(fmap1) : C1<A1>
>fa1.map : <B>(f: (a: A1) => B) => C1<A1>
>fa1 : C1<A1>
>map : <B>(f: (a: A1) => B) => C1<A1>
>fmap1 : (a1: A1) => B1
}

const liftedFunctor = lift(staticMap);
>liftedFunctor : LiftedResult<{}>
>lift(staticMap) : LiftedResult<{}>
>lift : <C>(fToLift: StaticFunctor<C<_T>>) => LiftedResult<C<_T>>
>staticMap : <C1 extends Functor<_T1, C1<_T1>>, A1, B1>(fa1: C1<A1>, fmap1: (a1: A1) => B1) => C1<B1>

function stringLength(strarg: string): number {
>stringLength : (strarg: string) => number
>strarg : string

    return strarg.length;
>strarg.length : number
>strarg : string
>length : number
}

const liftedStringLength = liftedFunctor(stringLength);
>liftedStringLength : <NC extends LRC<_NT>>(lrclra: NC<string>) => NC<number>
>liftedFunctor(stringLength) : <NC extends LRC<_NT>>(lrclra: NC<string>) => NC<number>
>liftedFunctor : LiftedResult<{}>
>stringLength : (strarg: string) => number

const functorXString = new FunctorX(["myFunctorX"]);
>functorXString : FunctorX<string>
>new FunctorX(["myFunctorX"]) : FunctorX<string>
>FunctorX : typeof FunctorX
>["myFunctorX"] : string[]
>"myFunctorX" : "myFunctorX"

const result = liftedStringLength(functorXString);
>result : FunctorX<number>
>liftedStringLength(functorXString) : FunctorX<number>
>liftedStringLength : <NC extends LRC<_NT>>(lrclra: NC<string>) => NC<number>
>functorXString : FunctorX<string>

const expectedType: FunctorX<number> = result;
>expectedType : FunctorX<number>
>FunctorX : FunctorX<A>
>result : FunctorX<number>

const expectError = liftedStringLength(result)
>expectError : any
>liftedStringLength(result) : any
>liftedStringLength : <NC extends LRC<_NT>>(lrclra: NC<string>) => NC<number>
>result : FunctorX<number>


