=== tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts ===
export {}

declare function identity1<T, U>(f: (t: T) => U): (t2: T) => U
>identity1 : <T, U>(f: (t: T) => U) => (t2: T) => U
>T : T
>U : U
>f : (t: T) => U
>t : T
>T : T
>U : U
>t2 : T
>T : T
>U : U

const id1 = identity1(x => x)
>id1 : (t2: {}) => {}
>identity1(x => x) : (t2: {}) => {}
>identity1 : <T, U>(f: (t: T) => U) => (t2: T) => U
>x => x : (x: {}) => {}
>x : {}
>x : {}


declare function identity2<T extends number, U>(f: (t: T) => U): (t2: T) => U
>identity2 : <T extends number, U>(f: (t: T) => U) => (t2: T) => U
>T : T
>U : U
>f : (t: T) => U
>t : T
>T : T
>U : U
>t2 : T
>T : T
>U : U

const id2 = identity2(x => x)
>id2 : (t2: number) => number
>identity2(x => x) : (t2: number) => number
>identity2 : <T extends number, U>(f: (t: T) => U) => (t2: T) => U
>x => x : (x: number) => number
>x : number
>x : number


// compose<D, E extends string, F> is just something I put in to make sure the contextual types handle multiple signatures.
declare function compose<D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F];
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>D : D
>E : E
>F : F
>f : (d: D) => E
>d : D
>D : D
>E : E
>g : (e: E) => F
>e : E
>E : E
>F : F
>d2 : D
>D : D
>D : D
>F : F

declare function compose<A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C;
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>A : A
>B : B
>C : C
>f : (a1: A) => B
>a1 : A
>A : A
>B : B
>g : (b1: B) => C
>b1 : B
>B : B
>C : C
>a2 : A
>A : A
>C : C

{
    let composed1 = compose(x => x, x2 => x2)
>composed1 : (a2: {}) => {}
>compose(x => x, x2 => x2) : (a2: {}) => {}
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>x => x : (x: {}) => {}
>x : {}
>x : {}
>x2 => x2 : (x2: {}) => {}
>x2 : {}
>x2 : {}

    const expectedComposed1: <U>(u: U) => U = composed1;
>expectedComposed1 : <U>(u: U) => U
>U : U
>u : U
>U : U
>U : U
>composed1 : (a2: {}) => {}

    const callComposed1 = composed1("test");
>callComposed1 : {}
>composed1("test") : {}
>composed1 : (a2: {}) => {}
>"test" : "test"

    const expectedCallComposed1 : string = callComposed1;
>expectedCallComposed1 : string
>callComposed1 : {}
}

{
    let composed2 = compose(x => x, x2 => [x2])
>composed2 : (a2: {}) => {}[]
>compose(x => x, x2 => [x2]) : (a2: {}) => {}[]
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>x => x : (x: {}) => {}
>x : {}
>x : {}
>x2 => [x2] : (x2: {}) => {}[]
>x2 : {}
>[x2] : {}[]
>x2 : {}

    const expectedComposed2: <U>(u: U) => U[] = composed2;
>expectedComposed2 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed2 : (a2: {}) => {}[]

    const callComposed2 = composed2("test");
>callComposed2 : {}[]
>composed2("test") : {}[]
>composed2 : (a2: {}) => {}[]
>"test" : "test"

    const expectedCallComposed2: string[] = callComposed2;
>expectedCallComposed2 : string[]
>callComposed2 : {}[]
}

{
    let composed3 = compose(x => [x], x2 => x2)
>composed3 : (a2: {}) => {}[]
>compose(x => [x], x2 => x2) : (a2: {}) => {}[]
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>x => [x] : (x: {}) => {}[]
>x : {}
>[x] : {}[]
>x : {}
>x2 => x2 : (x2: {}[]) => {}[]
>x2 : {}[]
>x2 : {}[]

    const expectedComposed3: <U>(u: U) => U[] = composed3;
>expectedComposed3 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed3 : (a2: {}) => {}[]

    const callComposed3 = composed3("test");
>callComposed3 : {}[]
>composed3("test") : {}[]
>composed3 : (a2: {}) => {}[]
>"test" : "test"

    const expectedCallComposed3 : string[] = callComposed3;
>expectedCallComposed3 : string[]
>callComposed3 : {}[]
}

{
    let composed4 = compose(x => [x], x2 => ({ boxed: x2 }));
>composed4 : (a2: {}) => { boxed: {}[]; }
>compose(x => [x], x2 => ({ boxed: x2 })) : (a2: {}) => { boxed: {}[]; }
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>x => [x] : (x: {}) => {}[]
>x : {}
>[x] : {}[]
>x : {}
>x2 => ({ boxed: x2 }) : (x2: {}[]) => { boxed: {}[]; }
>x2 : {}[]
>({ boxed: x2 }) : { boxed: {}[]; }
>{ boxed: x2 } : { boxed: {}[]; }
>boxed : {}[]
>x2 : {}[]

    const expectedComposed4: <U>(u: U) => {boxed: U[]} = composed4;
>expectedComposed4 : <U>(u: U) => { boxed: U[]; }
>U : U
>u : U
>U : U
>boxed : U[]
>U : U
>composed4 : (a2: {}) => { boxed: {}[]; }

    const callComposed4 = composed4("test");
>callComposed4 : { boxed: {}[]; }
>composed4("test") : { boxed: {}[]; }
>composed4 : (a2: {}) => { boxed: {}[]; }
>"test" : "test"

    const expectedCallComposed4 : {boxed: string[]} = callComposed4;
>expectedCallComposed4 : { boxed: string[]; }
>boxed : string[]
>callComposed4 : { boxed: {}[]; }
}

{
    let composed5 = compose(x => "" + x, x2 => ({ boxed: x2 }));
>composed5 : (d2: {}) => [{}, { boxed: string; }]
>compose(x => "" + x, x2 => ({ boxed: x2 })) : (d2: {}) => [{}, { boxed: string; }]
>compose : { <D, E extends string, F>(f: (d: D) => E, g: (e: E) => F): (d2: D) => [D, F]; <A, B, C>(f: (a1: A) => B, g: (b1: B) => C): (a2: A) => C; }
>x => "" + x : (x: {}) => string
>x : {}
>"" + x : string
>"" : ""
>x : {}
>x2 => ({ boxed: x2 }) : (x2: string) => { boxed: string; }
>x2 : string
>({ boxed: x2 }) : { boxed: string; }
>{ boxed: x2 } : { boxed: string; }
>boxed : string
>x2 : string

    const expectedComposed5: <U>(u: U) => [U, {boxed: string}] = composed5;
>expectedComposed5 : <U>(u: U) => [U, { boxed: string; }]
>U : U
>u : U
>U : U
>U : U
>boxed : string
>composed5 : (d2: {}) => [{}, { boxed: string; }]

    const callComposed5 = composed5(123456);
>callComposed5 : [{}, { boxed: string; }]
>composed5(123456) : [{}, { boxed: string; }]
>composed5 : (d2: {}) => [{}, { boxed: string; }]
>123456 : 123456

    const expectedCallComposed5 : [number, {boxed: string}] = callComposed5;
>expectedCallComposed5 : [number, { boxed: string; }]
>boxed : string
>callComposed5 : [{}, { boxed: string; }]
}


declare function composeReverse<D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F];
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>D : D
>E : E
>F : F
>g : (e: E) => F
>e : E
>E : E
>F : F
>f : (d: D) => E
>d : D
>D : D
>E : E
>d2 : D
>D : D
>D : D
>F : F

declare function composeReverse<A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C;
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>A : A
>B : B
>C : C
>g : (b1: B) => C
>b1 : B
>B : B
>C : C
>f : (a1: A) => B
>a1 : A
>A : A
>B : B
>a2 : A
>A : A
>C : C


{
    let composed1 = composeReverse(x => x, x2 => x2)
>composed1 : any
>composeReverse(x => x, x2 => x2) : any
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>x => x : (x: string) => string
>x : string
>x : string
>x2 => x2 : (x2: {}) => {}
>x2 : {}
>x2 : {}

    const expectedComposed1: <U>(u: U) => U = composed1;
>expectedComposed1 : <U>(u: U) => U
>U : U
>u : U
>U : U
>U : U
>composed1 : any

    const callComposed1 = composed1("test");
>callComposed1 : any
>composed1("test") : any
>composed1 : any
>"test" : "test"

    const expectedCallComposed1 : string = callComposed1;
>expectedCallComposed1 : string
>callComposed1 : any
}

{
    let composed2 = composeReverse( x2 => [x2], x => x)
>composed2 : any
>composeReverse( x2 => [x2], x => x) : any
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>x2 => [x2] : (x2: string) => string[]
>x2 : string
>[x2] : string[]
>x2 : string
>x => x : (x: {}) => {}
>x : {}
>x : {}

    const expectedComposed2: <U>(u: U) => U[] = composed2;
>expectedComposed2 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed2 : any

    const callComposed2 = composed2("test");
>callComposed2 : any
>composed2("test") : any
>composed2 : any
>"test" : "test"

    const expectedCallComposed2: string[] = callComposed2;
>expectedCallComposed2 : string[]
>callComposed2 : any
}

{
    let composed3 = composeReverse( x2 => x2, x => [x])
>composed3 : any
>composeReverse( x2 => x2, x => [x]) : any
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>x2 => x2 : (x2: string) => string
>x2 : string
>x2 : string
>x => [x] : (x: {}) => {}[]
>x : {}
>[x] : {}[]
>x : {}

    const expectedComposed3: <U>(u: U) => U[] = composed3;
>expectedComposed3 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed3 : any

    const callComposed3 = composed3("test");
>callComposed3 : any
>composed3("test") : any
>composed3 : any
>"test" : "test"

    const expectedCallComposed3 : string[] = callComposed3;
>expectedCallComposed3 : string[]
>callComposed3 : any
}

{
    let composed4 = composeReverse( x2 => ({ boxed: x2 }), x => [x]);
>composed4 : any
>composeReverse( x2 => ({ boxed: x2 }), x => [x]) : any
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>x2 => ({ boxed: x2 }) : (x2: string) => { boxed: string; }
>x2 : string
>({ boxed: x2 }) : { boxed: string; }
>{ boxed: x2 } : { boxed: string; }
>boxed : string
>x2 : string
>x => [x] : (x: {}) => {}[]
>x : {}
>[x] : {}[]
>x : {}

    const expectedComposed4: <U>(u: U) => {boxed: U[]} = composed4;
>expectedComposed4 : <U>(u: U) => { boxed: U[]; }
>U : U
>u : U
>U : U
>boxed : U[]
>U : U
>composed4 : any

    const callComposed4 = composed4("test");
>callComposed4 : any
>composed4("test") : any
>composed4 : any
>"test" : "test"

    const expectedCallComposed4 : {boxed: string[]} = callComposed4;
>expectedCallComposed4 : { boxed: string[]; }
>boxed : string[]
>callComposed4 : any
}

{
    let composed5 = composeReverse( x2 => ({ boxed: x2 }), x => "" + x);
>composed5 : (d2: {}) => [{}, { boxed: string; }]
>composeReverse( x2 => ({ boxed: x2 }), x => "" + x) : (d2: {}) => [{}, { boxed: string; }]
>composeReverse : { <D, E extends string, F>(g: (e: E) => F, f: (d: D) => E): (d2: D) => [D, F]; <A, B, C>(g: (b1: B) => C, f: (a1: A) => B): (a2: A) => C; }
>x2 => ({ boxed: x2 }) : (x2: string) => { boxed: string; }
>x2 : string
>({ boxed: x2 }) : { boxed: string; }
>{ boxed: x2 } : { boxed: string; }
>boxed : string
>x2 : string
>x => "" + x : (x: {}) => string
>x : {}
>"" + x : string
>"" : ""
>x : {}

    const expectedComposed5: <U>(u: U) => [U, {boxed: string}] = composed5;
>expectedComposed5 : <U>(u: U) => [U, { boxed: string; }]
>U : U
>u : U
>U : U
>U : U
>boxed : string
>composed5 : (d2: {}) => [{}, { boxed: string; }]

    const callComposed5 = composed5(123456);
>callComposed5 : [{}, { boxed: string; }]
>composed5(123456) : [{}, { boxed: string; }]
>composed5 : (d2: {}) => [{}, { boxed: string; }]
>123456 : 123456

    const expectedCallComposed5 : [number, {boxed: string}] = callComposed5;
>expectedCallComposed5 : [number, { boxed: string; }]
>boxed : string
>callComposed5 : [{}, { boxed: string; }]
}

