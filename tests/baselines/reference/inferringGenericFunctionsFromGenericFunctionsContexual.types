=== tests/cases/compiler/inferringGenericFunctionsFromGenericFunctionsContexual.ts ===
export {}

declare function identity1<T, U>(f: (t: T) => U): (t2: T) => U
>identity1 : <T, U>(f: (t: T) => U) => (t2: T) => U
>T : T
>U : U
>f : (t: T) => U
>t : T
>T : T
>U : U
>t2 : T
>T : T
>U : U

const id1 = identity1(x => x)
>id1 : <T>(t2: T) => T
>identity1(x => x) : <T>(t2: T) => T
>identity1 : <T, U>(f: (t: T) => U) => (t2: T) => U
>x => x : (x: T) => T
>x : T
>x : T


declare function identity2<T>(f: T): T
>identity2 : <T>(f: T) => T
>T : T
>f : T
>T : T
>T : T

const id2 = identity2(x => x)
>id2 : (x: any) => any
>identity2(x => x) : (x: any) => any
>identity2 : <T>(f: T) => T
>x => x : (x: any) => any
>x : any
>x : any


declare function identity3<T extends number, U>(f: (t: T) => U): (t2: T) => U
>identity3 : <T extends number, U>(f: (t: T) => U) => (t2: T) => U
>T : T
>U : U
>f : (t: T) => U
>t : T
>T : T
>U : U
>t2 : T
>T : T
>U : U

const id3 = identity3(x => x)
>id3 : (t2: number) => number
>identity3(x => x) : (t2: number) => number
>identity3 : <T extends number, U>(f: (t: T) => U) => (t2: T) => U
>x => x : (x: number) => number
>x : number
>x : number





declare function compose<A, B, C>(f: (x: A) => B, g: (y: B) => C): (x: A) => C;
>compose : <A, B, C>(f: (x: A) => B, g: (y: B) => C) => (x: A) => C
>A : A
>B : B
>C : C
>f : (x: A) => B
>x : A
>A : A
>B : B
>g : (y: B) => C
>y : B
>B : B
>C : C
>x : A
>A : A
>C : C

{
    let composed1 = compose(x => x, x2 => x2)
>composed1 : <A>(x: A) => A
>compose(x => x, x2 => x2) : <A>(x: A) => A
>compose : <A, B, C>(f: (x: A) => B, g: (y: B) => C) => (x: A) => C
>x => x : (x: A) => A
>x : A
>x : A
>x2 => x2 : (x2: A) => A
>x2 : A
>x2 : A

    const expectedComposed1: <U>(u: U) => U = composed1;
>expectedComposed1 : <U>(u: U) => U
>U : U
>u : U
>U : U
>U : U
>composed1 : <A>(x: A) => A

    const callComposed1 = composed1("test");
>callComposed1 : "test"
>composed1("test") : "test"
>composed1 : <A>(x: A) => A
>"test" : "test"

    const expectedCallComposed1 : string = callComposed1;
>expectedCallComposed1 : string
>callComposed1 : "test"
}

{
    let composed2 = compose(x => x, x2 => [x2])
>composed2 : <A>(x: A) => A[]
>compose(x => x, x2 => [x2]) : <A>(x: A) => A[]
>compose : <A, B, C>(f: (x: A) => B, g: (y: B) => C) => (x: A) => C
>x => x : (x: A) => A
>x : A
>x : A
>x2 => [x2] : (x2: A) => A[]
>x2 : A
>[x2] : A[]
>x2 : A

    const expectedComposed2: <U>(u: U) => U[] = composed2;
>expectedComposed2 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed2 : <A>(x: A) => A[]

    const callComposed2 = composed2("test");
>callComposed2 : string[]
>composed2("test") : string[]
>composed2 : <A>(x: A) => A[]
>"test" : "test"

    const expectedCallComposed2: string[] = callComposed2;
>expectedCallComposed2 : string[]
>callComposed2 : string[]
}

{
    let composed3 = compose(x => [x], x2 => x2)
>composed3 : <A>(x: A) => A[]
>compose(x => [x], x2 => x2) : <A>(x: A) => A[]
>compose : <A, B, C>(f: (x: A) => B, g: (y: B) => C) => (x: A) => C
>x => [x] : (x: A) => A[]
>x : A
>[x] : A[]
>x : A
>x2 => x2 : (x2: A[]) => A[]
>x2 : A[]
>x2 : A[]

    const expectedComposed3: <U>(u: U) => U[] = composed3;
>expectedComposed3 : <U>(u: U) => U[]
>U : U
>u : U
>U : U
>U : U
>composed3 : <A>(x: A) => A[]

    const callComposed3 = composed3("test");
>callComposed3 : string[]
>composed3("test") : string[]
>composed3 : <A>(x: A) => A[]
>"test" : "test"

    const expectedCallComposed3 : string[] = callComposed3;
>expectedCallComposed3 : string[]
>callComposed3 : string[]
}

{
    let composed4 = compose(x => [x], x2 => ({ boxed: x2 }));
>composed4 : <A>(x: A) => { boxed: A[]; }
>compose(x => [x], x2 => ({ boxed: x2 })) : <A>(x: A) => { boxed: A[]; }
>compose : <A, B, C>(f: (x: A) => B, g: (y: B) => C) => (x: A) => C
>x => [x] : (x: A) => A[]
>x : A
>[x] : A[]
>x : A
>x2 => ({ boxed: x2 }) : (x2: A[]) => { boxed: A[]; }
>x2 : A[]
>({ boxed: x2 }) : { boxed: A[]; }
>{ boxed: x2 } : { boxed: A[]; }
>boxed : A[]
>x2 : A[]

    const expectedComposed4: <U>(u: U) => {boxed: U[]} = composed4;
>expectedComposed4 : <U>(u: U) => { boxed: U[]; }
>U : U
>u : U
>U : U
>boxed : U[]
>U : U
>composed4 : <A>(x: A) => { boxed: A[]; }

    const callComposed4 = composed4("test");
>callComposed4 : { boxed: string[]; }
>composed4("test") : { boxed: string[]; }
>composed4 : <A>(x: A) => { boxed: A[]; }
>"test" : "test"

    const expectedCallComposed4 : {boxed: string[]} = callComposed4;
>expectedCallComposed4 : { boxed: string[]; }
>boxed : string[]
>callComposed4 : { boxed: string[]; }
}

